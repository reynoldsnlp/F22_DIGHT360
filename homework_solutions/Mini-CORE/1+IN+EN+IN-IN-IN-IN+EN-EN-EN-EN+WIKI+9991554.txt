<9991554>
<http://en.wikipedia.org/wiki/Composition_over_inheritance>
<Rater 1: IN_EN * Wiki>
<Rater 2: IN_EN * Wiki>
<Rater 3: IN_EN * Wiki>
<Rater 4: IN_EN * Wiki>
<h> Contents
<p> An implementation of composition over inheritance typically begins with the creation of various interfaces representing the behaviors that the system must exhibit. The use of interfaces allows this technique to support the polymorphic behavior that is so valuable in object-oriented programming. Classes implementing the identified interfaces are built and added to business-domain classes as needed. Thus, system behaviors are realized without inheritance. In fact, business-domain classes may all be base classes without any inheritance at all. Alternative implementation of system behaviors is accomplished by providing another class that implements the desired behavior interface. Any business-domain class that contains a reference to the interface can easily support any implementation of that interface and the choice can even be delayed until run time.
<p> Using inheritance we either have to do multiple inheritance, which leads to the diamond problem , or make classes like VisibleAndSolid , VisibleAndMovable , VisibleAndSolidAndMovable , etc. for every needed combination, which leads to a large amount of repetitive code.
<p> The following C++ and C# examples demonstrate the principle of using composition and interfaces to achieve code reuse and polymorphism. Due to the C++ language not having a dedicated keyword to declare interfaces, the C++ example uses "inheritance from a pure abstract base class". For most purposes, this is functionally equivalent to the interfaces provided in other languages, such as Java and C#.
<p> To favor composition over inheritance is a design principle that gives the design higher flexibility, giving business-domain classes and more stable business domain in the long term. In other words, HAS-A can be better than an IS-A relationship. [ 1 ] [ vague ]
<p> Initial design is simplified by identifying system object behaviors in separate interfaces instead of creating a hierarchical relationship to distribute behaviors among business-domain classes via inheritance. This approach more easily accommodates future requirements changes that would otherwise require a complete restructuring of business-domain classes in the inheritance model. Additionally, it avoids problems [ 3 ] often associated with relatively minor changes to an inheritance-based model that includes several generations of classes.
<p> One drawback to using composition in place of inheritance is that all of the methods being provided by the composed classes must be implemented in the derived class, even if they are only forwarding methods . In contrast, inheritance does not require all of a base class's methods to be re-implemented within the derived class. Rather, the derived class need only implement (override) the methods having different behavior than the base class methods. This can require significantly less programming effort if the base class contains many methods providing default behavior and only a few of them need to be overridden within the derived class. This drawback can be avoided by using traits or mixins .
